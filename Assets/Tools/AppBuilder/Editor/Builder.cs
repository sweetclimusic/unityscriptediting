using UnityEditor;
using UnityEngine;
using System.Collections.Generic;

namespace AppBuilder{
	public class Builder{

		private static string buildFolderPath = Application.dataPath +
			"/../Build";
		//array of Levels in the scene... look in Assest\Scenes
		/// <summary>
		/// Gets the path for enabled scenes from EditorBuildSettingsScene.
		/// </summary>
		/// <returns>The enabled scenes.</returns>
		static string[] getEnabledScenes(){
			List<string> scenes = new List<string> ();
			foreach (EditorBuildSettingsScene s in EditorBuildSettings.scenes) {
				if (s.enabled) {
					scenes.Add (s.path);
				}
			}
			return scenes.ToArray ();
		}
		/// <summary>
		/// Creates the build folder to store all our game builds.
		/// </summary>
		public static void CreateBuildFolder () {
			if (System.IO.Directory.Exists (buildFolderPath)) {
				System.IO.Directory.Delete (buildFolderPath, true);
			}
			System.IO.Directory.CreateDirectory (buildFolderPath);
		}
		public static void Build(BuildTarget target, string buildName){
			//grab our settings
			BuildSettings.UpdateSettings ();
			GenerateBuildInfo ();
			string fullPath = buildFolderPath + "/" + target + "/" +
				buildName;
			
			BuildPipeline.BuildPlayer (getEnabledScenes (),fullPath,target,BuildOptions.None);

		}
		//able to execute shell scripts.
		//this allows starting and stopping of processes from unity.
		private static string ExecuteCommand (string command, string arguments = "") {
			System.Diagnostics.Process pProcess = new
				System.Diagnostics.Process ();
			pProcess.StartInfo.FileName = command;
			pProcess.StartInfo.Arguments = arguments;
			pProcess.StartInfo.UseShellExecute = false;
			pProcess.StartInfo.RedirectStandardOutput = true;
			pProcess.Start ();
			string strOutput = pProcess.StandardOutput.ReadToEnd ();
			pProcess.WaitForExit ();
			return strOutput;
		} 

		private static string batchPath = Application.dataPath +
			"/Tools/AppBuilder/Bash";
		//encapsulate the bash script for all other C# scripts to interact with.
		private static string GitHash () {
			string command = batchPath + "/mac_githash.sh";
			string output = ExecuteCommand (command);
			// We trim the output to remove new lines at the end.
			return output.Trim();
		}

		private static void GenerateBuildInfo () {
			string content = "";
			string hash = GitHash();
			string date = System.DateTime.Now.ToString();;
			content += "namespace AppBuilder {\n";
			content += "\tpublic class BuildInfo {\n";
			content += string.Format("\t\tpublic const string Hash = \"{0}\";\n", hash);
			content += string.Format("\t\tpublic const string Date = \"{0}\";\n", date);
			content += "\t}";
			content += "}";
			string buildInfoPath = Application.dataPath +
				"/Tools/AppBuilder/Scripts/BuildInfo.Autogenerated.cs";
			System.IO.File.WriteAllText (buildInfoPath, content);
		}
	}
}
